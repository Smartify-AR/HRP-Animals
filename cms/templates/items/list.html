{% extends "base.html" %}

{% block title %}Items - CMS{% endblock %}

{% block extra_head %}
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<script type="module" src="https://modelviewer.dev/node_modules/@google/model-viewer/dist/model-viewer.min.js"></script>
<style>
    #previewContainer {
        min-height: 400px;
        padding: 20px;
        border: 2px dashed #ddd;
        border-radius: 8px;
        background: #f9f9f9;
        display: block !important;
        width: 100% !important;
        box-sizing: border-box;
        visibility: visible !important;
        opacity: 1 !important;
    }
    .preview-item {
        margin-bottom: 20px;
        padding: 15px;
        background: white;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-height: 100px;
        display: block !important;
        width: 100%;
        box-sizing: border-box;
        overflow: visible;
    }
    .preview-item h6 {
        margin-bottom: 10px;
        color: #333;
        font-weight: 600;
    }
    .preview-image {
        max-width: 100%;
        max-height: 200px;
        min-width: 100px;
        min-height: 100px;
        width: auto;
        height: auto;
        object-fit: contain;
        border-radius: 4px;
        display: block;
        margin: 10px auto;
        background: white;
        padding: 10px;
    }
    .preview-image-container {
        text-align: center;
        padding: 10px;
        min-height: 120px;
        min-width: 100px;
        display: flex !important;
        align-items: center;
        justify-content: center;
        width: 100%;
        box-sizing: border-box;
    }
    model-viewer {
        width: 100%;
        height: 400px;
        background: #FCF6EF;
        border-radius: 4px;
    }
    .preview-placeholder {
        text-align: center;
        color: #999;
        padding: 40px 20px;
        font-style: italic;
    }
    .model-viewer-container {
        position: relative;
    }
    .model-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 10;
    }
    .model-controls button {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s;
    }
    .model-controls button:hover {
        background: #f0f0f0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .model-controls button:active {
        transform: scale(0.95);
    }
    .model-controls button svg {
        width: 20px;
        height: 20px;
    }
    .model-controls-row {
        display: flex;
        gap: 5px;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-md-6">
        <h1>Collectable Items</h1>
    </div>
    <div class="col-md-6 text-end">
        <a href="{{ url_for('item.create') }}" class="btn btn-primary">Create New Item</a>
    </div>
</div>

<div class="row mb-3">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <label for="item_select" class="form-label mb-0"><strong>Select Item to View</strong></label>
                    <small class="text-muted">{{ all_items|length }} item{{ 's' if all_items|length != 1 else '' }} available</small>
                </div>
                <form method="GET" action="{{ url_for('item.list') }}" class="d-flex gap-2" id="itemSelectForm">
                    <select class="form-select" id="item_select" name="item_id" onchange="this.form.submit()">
                        <option value="">-- Select an item --</option>
                        {% for item in all_items %}
                        <option value="{{ item.id }}" {% if item.id == selected_id %}selected{% endif %}>
                            {{ item.name }} ({{ item.id }})
                        </option>
                        {% endfor %}
                    </select>
                    {% if selected_id %}
                    <a href="{{ url_for('item.list') }}" class="btn btn-outline-secondary">Clear Selection</a>
                    {% endif %}
                    <button type="button" class="btn btn-outline-primary" onclick="location.reload()" title="Refresh to get latest data">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                            <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                        Refresh
                    </button>
                </form>
                <small class="text-muted mt-2 d-block">Data is loaded fresh from assets.json on each page load</small>
            </div>
        </div>
    </div>
</div>

{% if selected_item %}
<div class="row">
    <div class="col-md-6">
        <!-- Item Details Table -->
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Item Details</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <tbody>
                            <tr>
                                <th width="30%">ID</th>
                                <td><code>{{ selected_item.id }}</code></td>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <td>{{ selected_item.name }}</td>
                            </tr>
                            <tr>
                                <th>Scientific Name</th>
                                <td>{{ selected_item.scientificName or '-' }}</td>
                            </tr>
                            <tr>
                                <th>Description</th>
                                <td>{{ selected_item.description or '-' }}</td>
                            </tr>
                            <tr>
                                <th>Location</th>
                                <td>
                                    {% if selected_item.location %}
                                        {{ "%.6f"|format(selected_item.location.lat) }}, {{ "%.6f"|format(selected_item.location.lng) }}
                                    {% else %}
                                        <span class="text-muted">Not set</span>
                                    {% endif %}
                                </td>
                            </tr>
                            <tr>
                                <th>Radius</th>
                                <td>{{ selected_item.radiusMeters or 10 }}m</td>
                            </tr>
                            <tr>
                                <th>Actions</th>
                                <td>
                                    <a href="{{ url_for('item.edit', item_id=selected_item.id) }}" 
                                       class="btn btn-sm btn-primary">Edit</a>
                                    <form method="POST" action="{{ url_for('item.duplicate', item_id=selected_item.id) }}" 
                                          class="d-inline" onsubmit="return confirm('Duplicate this item?');">
                                        <button type="submit" class="btn btn-sm btn-secondary">Duplicate</button>
                                    </form>
                                    <form method="POST" action="{{ url_for('item.delete', item_id=selected_item.id) }}" 
                                          class="d-inline" onsubmit="return confirm('Are you sure you want to delete this item?');">
                                        <button type="submit" class="btn btn-sm btn-danger">Delete</button>
                                    </form>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-6">
        <!-- Preview Section -->
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Asset Preview</h5>
            </div>
            <div class="card-body">
                <div class="preview-container" id="previewContainer">
                    <div class="preview-placeholder">
                        <p>Loading preview...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% else %}
<div class="row">
    <div class="col-12">
        <div class="alert alert-info">
            <p class="mb-0">Please select an item from the dropdown above to view its details and preview assets.</p>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_scripts %}
<script>
function convertAssetPath(relativePath) {
    // Convert relative paths like ../../assets/... to /assets/...
    if (relativePath && relativePath.startsWith('../../assets/')) {
        return relativePath.replace('../../assets/', '/assets/');
    }
    // If already absolute, return as is
    if (relativePath && relativePath.startsWith('/')) {
        return relativePath;
    }
    return relativePath;
}

// Auto-rotation pause management
const autoRotateTimers = {};

// Track camera state for each viewer
const cameraState = {};

function pauseAutoRotate(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (viewer) {
        // Disable auto-rotate
        viewer.removeAttribute('auto-rotate');
        
        // Clear any existing timer for this viewer
        if (autoRotateTimers[viewerId]) {
            clearTimeout(autoRotateTimers[viewerId]);
        }
        
        // Re-enable auto-rotate after 20 seconds
        autoRotateTimers[viewerId] = setTimeout(() => {
            viewer.setAttribute('auto-rotate', '');
            delete autoRotateTimers[viewerId];
        }, 20000);
    }
}

// Initialize camera state tracking for a viewer
function initCameraState(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (!viewer) return;
    
    // Initialize state from current attribute (in degrees)
    const currentOrbit = viewer.getAttribute('camera-orbit') || '0deg 75deg 1.5m';
    const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
    if (parts && parts.length >= 4) {
        // Store in radians (to match getCameraOrbit() format)
        cameraState[viewerId] = {
            theta: (parseFloat(parts[1]) || 0) * (Math.PI / 180),
            phi: (parseFloat(parts[2]) || 75) * (Math.PI / 180),
            radius: parseFloat(parts[3]) || 1.5
        };
    } else {
        cameraState[viewerId] = { theta: 0, phi: 75 * (Math.PI / 180), radius: 1.5 };
    }
    
    // Update state when camera changes (user interaction or programmatic change)
    // Use a debounced update to avoid too many updates
    let updateTimeout;
    const updateState = () => {
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(() => {
            try {
                const orbit = viewer.getCameraOrbit();
                if (orbit && typeof orbit.theta !== 'undefined') {
                    // getCameraOrbit() returns values in RADIANS - store as-is
                    cameraState[viewerId] = {
                        theta: parseFloat(orbit.theta) || 0,
                        phi: parseFloat(orbit.phi) || 75 * (Math.PI / 180),
                        radius: parseFloat(orbit.radius) || 1.5
                    };
                } else {
                    // Fallback: parse from attribute (convert to radians)
                    const currentOrbit = viewer.getAttribute('camera-orbit');
                    if (currentOrbit) {
                        const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
                        if (parts && parts.length >= 4) {
                            cameraState[viewerId] = {
                                theta: (parseFloat(parts[1]) || 0) * (Math.PI / 180),
                                phi: (parseFloat(parts[2]) || 75) * (Math.PI / 180),
                                radius: parseFloat(parts[3]) || 1.5
                            };
                        }
                    }
                }
            } catch (e) {
                // If getCameraOrbit fails, try to parse from attribute (convert to radians)
                const currentOrbit = viewer.getAttribute('camera-orbit');
                if (currentOrbit) {
                    const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
                    if (parts && parts.length >= 4) {
                        cameraState[viewerId] = {
                            theta: (parseFloat(parts[1]) || 0) * (Math.PI / 180),
                            phi: (parseFloat(parts[2]) || 75) * (Math.PI / 180),
                            radius: parseFloat(parts[3]) || 1.5
                        };
                    }
                }
            }
        }, 50); // Small delay to ensure state is updated
    };
    
    // Listen to camera-change events
    viewer.addEventListener('camera-change', updateState);
    
    // Also update on user interaction events
    ['mousedown', 'touchstart', 'wheel'].forEach(eventType => {
        viewer.addEventListener(eventType, updateState);
    });
}

// Model viewer control functions
function zoomIn(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (!viewer) return;
    
    pauseAutoRotate(viewerId);
    
    // Read current orbit directly from viewer - MUST get current state, not initial
    // NOTE: getCameraOrbit() returns values in RADIANS, not degrees!
    let currentTheta, currentPhi, currentRadius;
    
    // Try to get from tracked state first (updated by camera-change events)
    if (cameraState[viewerId]) {
        // Convert radians to degrees
        currentTheta = (cameraState[viewerId].theta || 0) * (180 / Math.PI);
        currentPhi = (cameraState[viewerId].phi || 75) * (180 / Math.PI);
        currentRadius = cameraState[viewerId].radius || 1.5;
    } else {
        // Try API
        try {
            const orbit = viewer.getCameraOrbit();
            if (orbit && typeof orbit.theta !== 'undefined' && typeof orbit.phi !== 'undefined' && typeof orbit.radius !== 'undefined') {
                // Convert radians to degrees
                currentTheta = parseFloat(orbit.theta) * (180 / Math.PI) || 0;
                currentPhi = parseFloat(orbit.phi) * (180 / Math.PI) || 75;
                currentRadius = parseFloat(orbit.radius) || 1.5;
            } else {
                throw new Error('Invalid orbit object');
            }
        } catch (e) {
            // Last resort: read from attribute (already in degrees)
            const currentOrbit = viewer.getAttribute('camera-orbit') || '0deg 75deg 1.5m';
            const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
            if (!parts || parts.length < 4) return;
            currentTheta = parseFloat(parts[1]) || 0;
            currentPhi = parseFloat(parts[2]) || 75;
            currentRadius = parseFloat(parts[3]) || 1.5;
        }
    }
    
    // Decrease radius (zoom in) - preserve theta and phi
    const newRadius = Math.max(currentRadius * 0.8, 0.1);
    viewer.cameraOrbit = `${currentTheta}deg ${currentPhi}deg ${newRadius}m`;
    
    // Update tracked state
    if (cameraState[viewerId]) {
        cameraState[viewerId].radius = newRadius;
    }
}

function zoomOut(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (!viewer) return;
    
    pauseAutoRotate(viewerId);
    
    // Read current orbit directly from viewer - MUST get current state, not initial
    // NOTE: getCameraOrbit() returns values in RADIANS, not degrees!
    let currentTheta, currentPhi, currentRadius;
    
    // Try to get from tracked state first (updated by camera-change events)
    if (cameraState[viewerId]) {
        // Convert radians to degrees
        currentTheta = (cameraState[viewerId].theta || 0) * (180 / Math.PI);
        currentPhi = (cameraState[viewerId].phi || 75) * (180 / Math.PI);
        currentRadius = cameraState[viewerId].radius || 1.5;
    } else {
        // Try API
        try {
            const orbit = viewer.getCameraOrbit();
            if (orbit && typeof orbit.theta !== 'undefined' && typeof orbit.phi !== 'undefined' && typeof orbit.radius !== 'undefined') {
                // Convert radians to degrees
                currentTheta = parseFloat(orbit.theta) * (180 / Math.PI) || 0;
                currentPhi = parseFloat(orbit.phi) * (180 / Math.PI) || 75;
                currentRadius = parseFloat(orbit.radius) || 1.5;
            } else {
                throw new Error('Invalid orbit object');
            }
        } catch (e) {
            // Last resort: read from attribute (already in degrees)
            const currentOrbit = viewer.getAttribute('camera-orbit') || '0deg 75deg 1.5m';
            const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
            if (!parts || parts.length < 4) return;
            currentTheta = parseFloat(parts[1]) || 0;
            currentPhi = parseFloat(parts[2]) || 75;
            currentRadius = parseFloat(parts[3]) || 1.5;
        }
    }
    
    // Increase radius (zoom out) - preserve theta and phi
    const newRadius = Math.min(currentRadius * 1.25, 10);
    viewer.cameraOrbit = `${currentTheta}deg ${currentPhi}deg ${newRadius}m`;
    
    // Update tracked state
    if (cameraState[viewerId]) {
        cameraState[viewerId].radius = newRadius;
    }
}

function rotateLeft(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (!viewer) return;
    
    pauseAutoRotate(viewerId);
    
    // Read current orbit directly from viewer - MUST get current state, not initial
    let currentTheta, currentPhi, currentRadius;
    
    // Try to get from tracked state first (updated by camera-change events)
    // NOTE: getCameraOrbit() returns values in RADIANS, not degrees!
    if (cameraState[viewerId]) {
        // Convert radians to degrees
        currentTheta = (cameraState[viewerId].theta || 0) * (180 / Math.PI);
        currentPhi = (cameraState[viewerId].phi || 75) * (180 / Math.PI);
        currentRadius = cameraState[viewerId].radius || 1.5;
        console.log('Rotate Left: Using tracked state (converted from radians)', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
    } else {
        // Try API
        try {
            const orbit = viewer.getCameraOrbit();
            if (orbit && typeof orbit.theta !== 'undefined' && typeof orbit.phi !== 'undefined' && typeof orbit.radius !== 'undefined') {
                // Convert radians to degrees
                currentTheta = parseFloat(orbit.theta) * (180 / Math.PI) || 0;
                currentPhi = parseFloat(orbit.phi) * (180 / Math.PI) || 75;
                currentRadius = parseFloat(orbit.radius) || 1.5;
                console.log('Rotate Left: Using getCameraOrbit() (converted from radians)', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
            } else {
                throw new Error('Invalid orbit object');
            }
        } catch (e) {
            // Last resort: read from attribute (already in degrees)
            const currentOrbit = viewer.getAttribute('camera-orbit') || '0deg 75deg 1.5m';
            const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
            if (!parts || parts.length < 4) {
                console.error('Rotate Left: Failed to parse orbit');
                return;
            }
            currentTheta = parseFloat(parts[1]) || 0;
            currentPhi = parseFloat(parts[2]) || 75;
            currentRadius = parseFloat(parts[3]) || 1.5;
            console.log('Rotate Left: Using attribute (already in degrees)', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
        }
    }
    
    // Ensure we have valid numbers
    if (isNaN(currentTheta)) currentTheta = 0;
    if (isNaN(currentPhi)) currentPhi = 75;
    if (isNaN(currentRadius)) currentRadius = 1.5;
    
    // Decrease theta by 15 degrees (rotate left/counter-clockwise)
    const newTheta = currentTheta - 15;
    // Normalize to 0-360 range
    let normalizedTheta = newTheta;
    while (normalizedTheta < 0) {
        normalizedTheta = normalizedTheta + 360;
    }
    while (normalizedTheta >= 360) {
        normalizedTheta = normalizedTheta - 360;
    }
    
    console.log('Rotate Left: Before', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
    console.log('Rotate Left: After', { theta: normalizedTheta, phi: currentPhi, radius: currentRadius });
    
    // Update camera orbit - ONLY change theta, preserve phi and radius
    viewer.cameraOrbit = `${normalizedTheta}deg ${currentPhi}deg ${currentRadius}m`;
    
    // Update tracked state
    if (cameraState[viewerId]) {
        cameraState[viewerId].theta = normalizedTheta;
    }
}

function rotateRight(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (!viewer) return;
    
    pauseAutoRotate(viewerId);
    
    // Read current orbit directly from viewer - MUST get current state, not initial
    let currentTheta, currentPhi, currentRadius;
    
    // Try to get from tracked state first (updated by camera-change events)
    // NOTE: getCameraOrbit() returns values in RADIANS, not degrees!
    if (cameraState[viewerId]) {
        // Convert radians to degrees
        currentTheta = (cameraState[viewerId].theta || 0) * (180 / Math.PI);
        currentPhi = (cameraState[viewerId].phi || 75) * (180 / Math.PI);
        currentRadius = cameraState[viewerId].radius || 1.5;
        console.log('Rotate Right: Using tracked state (converted from radians)', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
    } else {
        // Try API
        try {
            const orbit = viewer.getCameraOrbit();
            if (orbit && typeof orbit.theta !== 'undefined' && typeof orbit.phi !== 'undefined' && typeof orbit.radius !== 'undefined') {
                // Convert radians to degrees
                currentTheta = parseFloat(orbit.theta) * (180 / Math.PI) || 0;
                currentPhi = parseFloat(orbit.phi) * (180 / Math.PI) || 75;
                currentRadius = parseFloat(orbit.radius) || 1.5;
                console.log('Rotate Right: Using getCameraOrbit() (converted from radians)', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
            } else {
                throw new Error('Invalid orbit object');
            }
        } catch (e) {
            // Last resort: read from attribute (already in degrees)
            const currentOrbit = viewer.getAttribute('camera-orbit') || '0deg 75deg 1.5m';
            const parts = currentOrbit.match(/([\d.-]+)deg\s+([\d.-]+)deg\s+([\d.]+)m/);
            if (!parts || parts.length < 4) {
                console.error('Rotate Right: Failed to parse orbit');
                return;
            }
            currentTheta = parseFloat(parts[1]) || 0;
            currentPhi = parseFloat(parts[2]) || 75;
            currentRadius = parseFloat(parts[3]) || 1.5;
            console.log('Rotate Right: Using attribute (already in degrees)', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
        }
    }
    
    // Ensure we have valid numbers
    if (isNaN(currentTheta)) currentTheta = 0;
    if (isNaN(currentPhi)) currentPhi = 75;
    if (isNaN(currentRadius)) currentRadius = 1.5;
    
    // Increase theta by 15 degrees (rotate right/clockwise)
    const newTheta = currentTheta + 15;
    // Normalize to 0-360 range
    let normalizedTheta = newTheta;
    while (normalizedTheta < 0) {
        normalizedTheta = normalizedTheta + 360;
    }
    while (normalizedTheta >= 360) {
        normalizedTheta = normalizedTheta - 360;
    }
    
    console.log('Rotate Right: Before', { theta: currentTheta, phi: currentPhi, radius: currentRadius });
    console.log('Rotate Right: After', { theta: normalizedTheta, phi: currentPhi, radius: currentRadius });
    
    // Update camera orbit - ONLY change theta, preserve phi and radius
    viewer.cameraOrbit = `${normalizedTheta}deg ${currentPhi}deg ${currentRadius}m`;
    
    // Update tracked state
    if (cameraState[viewerId]) {
        cameraState[viewerId].theta = normalizedTheta;
    }
}

function panUp(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (viewer) {
        pauseAutoRotate(viewerId);
        const target = viewer.getCameraTarget();
        const newY = parseFloat(target.y) + 0.1;
        viewer.cameraTarget = `${target.x}m ${newY}m ${target.z}m`;
    }
}

function panDown(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (viewer) {
        pauseAutoRotate(viewerId);
        const target = viewer.getCameraTarget();
        const newY = parseFloat(target.y) - 0.1;
        viewer.cameraTarget = `${target.x}m ${newY}m ${target.z}m`;
    }
}

function panLeft(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (viewer) {
        pauseAutoRotate(viewerId);
        const target = viewer.getCameraTarget();
        const newX = parseFloat(target.x) - 0.1;
        viewer.cameraTarget = `${newX}m ${target.y}m ${target.z}m`;
    }
}

function panRight(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (viewer) {
        pauseAutoRotate(viewerId);
        const target = viewer.getCameraTarget();
        const newX = parseFloat(target.x) + 0.1;
        viewer.cameraTarget = `${newX}m ${target.y}m ${target.z}m`;
    }
}

function resetView(viewerId) {
    const viewer = document.getElementById(viewerId);
    if (viewer) {
        pauseAutoRotate(viewerId);
        viewer.cameraOrbit = '0deg 75deg 1.5m';
        viewer.cameraTarget = '0m 0m 0m';
    }
}

function updatePreview() {
    {% if selected_item %}
    const previewContainer = document.getElementById('previewContainer');
    if (!previewContainer) {
        console.error('Preview container not found');
        return;
    }
    
    const item = {{ selected_item | tojson }};
    
    const shadowPath = item.icon ? (item.icon.shadow || '').trim() : '';
    const foundPath = item.icon ? (item.icon.found || '').trim() : '';
    const badgeIconPath = item.badge ? (item.badge.icon || '').trim() : '';
    const modelUrl = item.model ? (item.model.url || '').trim() : '';
    const modelScale = item.model ? (item.model.scale || '1 1 1') : '1 1 1';
    const modelRotation = item.model ? (item.model.rotation || '0 0 0') : '0 0 0';
    
    let previewHTML = '';
    
    // 3D Model Preview (FIRST)
    if (modelUrl) {
        const absolutePath = convertAssetPath(modelUrl);
        const isGLB = modelUrl.toLowerCase().endsWith('.glb');
        const isUSDZ = modelUrl.toLowerCase().endsWith('.usdz');
        
        if (isGLB || isUSDZ) {
            const viewerId = 'preview-model-viewer-' + Date.now();
            previewHTML += `
                <div class="preview-item">
                    <h6>3D Model</h6>
                    <div class="model-viewer-container">
                        <model-viewer 
                            id="${viewerId}"
                            src="${absolutePath}" 
                            alt="3D Model"
                            autoplay
                            camera-controls
                            auto-rotate
                            interaction-prompt="none"
                            shadow-intensity="0.5"
                            shadow-softness="1.0"
                            exposure="1.0"
                            background-color="#FCF6EF"
                            camera-orbit="0deg 75deg 1.5m"
                            camera-target="0m 0m 0m"
                            style="width: 100%; height: 400px; background: #FCF6EF; border-radius: 4px;">
                        </model-viewer>
                        <div class="model-controls">
                            <div class="model-controls-row">
                                <button type="button" onclick="zoomIn('${viewerId}')" title="Zoom In">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                                    </svg>
                                </button>
                                <button type="button" onclick="zoomOut('${viewerId}')" title="Zoom Out">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="model-controls-row">
                                <button type="button" onclick="rotateLeft('${viewerId}')" title="Rotate Left">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-counterclockwise" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2z"/>
                                        <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466"/>
                                    </svg>
                                </button>
                                <button type="button" onclick="rotateRight('${viewerId}')" title="Rotate Right">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="model-controls-row">
                                <button type="button" onclick="panUp('${viewerId}')" title="Pan Up">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/>
                                    </svg>
                                </button>
                                <button type="button" onclick="panDown('${viewerId}')" title="Pan Down">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="model-controls-row">
                                <button type="button" onclick="panLeft('${viewerId}')" title="Pan Left">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/>
                                    </svg>
                                </button>
                                <button type="button" onclick="panRight('${viewerId}')" title="Pan Right">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="model-controls-row">
                                <button type="button" onclick="resetView('${viewerId}')" title="Reset View">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/>
                                        <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="mt-2">
                        <small class="text-muted">Scale: ${modelScale} | Rotation: ${modelRotation}</small>
                    </div>
                </div>
            `;
        } else {
            previewHTML += `
                <div class="preview-item">
                    <h6>3D Model</h6>
                    <p class="text-muted">Model URL must be a .glb or .usdz file</p>
                </div>
            `;
        }
    }
    
    // Found Icon Preview (SECOND)
    if (foundPath) {
        const absolutePath = convertAssetPath(foundPath);
        previewHTML += `
            <div class="preview-item">
                <h6>Found Icon</h6>
                <div class="preview-image-container">
                    <img src="${absolutePath}" alt="Found Icon" class="preview-image"
                         style="max-width: 200px; max-height: 200px; min-width: 100px; min-height: 100px; width: auto; height: auto; object-fit: contain;"
                         onload="if (this.naturalWidth === 0 || this.naturalHeight === 0) { this.style.width = '200px'; this.style.height = '200px'; }"
                         onerror="this.parentElement.innerHTML='<p class=\\'text-danger\\'>Failed to load image</p>'">
                </div>
            </div>
        `;
    }
    
    // Shadow Icon Preview (THIRD)
    if (shadowPath) {
        const absolutePath = convertAssetPath(shadowPath);
        previewHTML += `
            <div class="preview-item">
                <h6>Shadow Icon</h6>
                <div class="preview-image-container">
                    <img src="${absolutePath}" alt="Shadow Icon" class="preview-image" 
                         style="max-width: 200px; max-height: 200px; min-width: 100px; min-height: 100px; width: auto; height: auto; object-fit: contain;"
                         onload="if (this.naturalWidth === 0 || this.naturalHeight === 0) { this.style.width = '200px'; this.style.height = '200px'; }"
                         onerror="this.parentElement.innerHTML='<p class=\\'text-danger\\'>Failed to load image</p>'">
                </div>
            </div>
        `;
    }
    
    // Badge Icon Preview (FOURTH)
    if (badgeIconPath) {
        const absolutePath = convertAssetPath(badgeIconPath);
        previewHTML += `
            <div class="preview-item">
                <h6>Badge Icon</h6>
                <div class="preview-image-container">
                    <img src="${absolutePath}" alt="Badge Icon" class="preview-image"
                         style="max-width: 200px; max-height: 200px; min-width: 100px; min-height: 100px; width: auto; height: auto; object-fit: contain;"
                         onload="if (this.naturalWidth === 0 || this.naturalHeight === 0) { this.style.width = '200px'; this.style.height = '200px'; }"
                         onerror="this.parentElement.innerHTML='<p class=\\'text-danger\\'>Failed to load image</p>'">
                </div>
            </div>
        `;
    }
    
    if (previewHTML === '') {
        previewContainer.innerHTML = `
            <div class="preview-placeholder">
                <p>No assets configured for this item</p>
            </div>
        `;
    } else {
        previewContainer.innerHTML = previewHTML;
        
        // Force display of container
        previewContainer.style.display = 'block';
        previewContainer.style.visibility = 'visible';
        previewContainer.style.opacity = '1';
        
        // Wait for images to load
        setTimeout(() => {
            const images = previewContainer.querySelectorAll('img');
            images.forEach((img) => {
                img.style.display = 'block';
                img.style.visibility = 'visible';
                img.style.opacity = '1';
                
                if (img.naturalWidth === 0 || img.naturalHeight === 0) {
                    img.style.width = '200px';
                    img.style.height = '200px';
                }
            });
            
            // Set up auto-rotate pause on user interaction and initialize camera state
            const modelViewer = previewContainer.querySelector('model-viewer');
            if (modelViewer) {
                // Initialize camera state tracking
                initCameraState(modelViewer.id);
                
                // Pause auto-rotate when user interacts with mouse/touch
                ['mousedown', 'touchstart', 'wheel'].forEach(eventType => {
                    modelViewer.addEventListener(eventType, () => {
                        pauseAutoRotate(modelViewer.id);
                    });
                });
            }
        }, 300);
    }
    {% endif %}
}

// Update preview when page loads
document.addEventListener('DOMContentLoaded', function() {
    {% if selected_item %}
    setTimeout(updatePreview, 300);
    {% endif %}
});
</script>
{% endblock %}
